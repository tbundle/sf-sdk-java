/**
 * 					STRINGFLOW SDK LICENSE
 * 					http://stringflow.com/sdk-license
 *
 * 	This is an agreement between You ("You") and ALTERBASICS Technologies Pvt
 * 	Ltd., located at A1 306, Regency Orion, Baner,Pune, Maharashtra - 411045,
 * 	India, ("ALTERBASICS") regarding Your use of the Stringflow SDK and any
 * 	associated documentation or other materials made available by ALTERBASICS
 * 	(collectively the "SDK"). This agreement applies to any updates or
 * 	supplements for the SDK, unless other terms accompany those items. If so,
 * 	those other terms apply.
 *
 * 	By installing, accessing or otherwise using the SDK, You accept the terms
 * 	of this agreement. If You do not agree to the terms of this agreement, do
 * 	not install, access or use the SDK.
 *
 * 	If You comply with this agreement, You have the rights below.
 *
 * 	1. Use of the SDK.
 * 	   Subject to Your compliance with this agreement, Stringflow hereby
 * 	   authorizes You to use the SDK solely for the purpose of creating mobile
 * 	   applications designed to operate with the Services (referred to as
 * 	   "Authorized Applications"). You may not rent, lease or lend any of Your
 * 	   rights in the SDK or access to the Services. You may make a reasonable
 * 	   number of copies of the SDK for the purposes set forth herein, provided
 * 	   that You reproduce only complete copies, including without limitation
 * 	   all "read me" files, copyright notices, and other legal notices and
 * 	   terms that ALTERBASICS has included in the SDK.
 *
 * 	2. Scope of the License.
 * 	   The SDK is licensed, not sold. This agreement only gives You some rights
 * 	   to use the SDK. ALTERBASICS specifically does not grant any express or
 * 	   implied rights under its patents with respect to your Authorized
 * 	   Applications. In doing so, You must comply with any technical
 * 	   limitations in the SDK that only allow You to use it in certain ways.
 * 	   You may not:
 * 	    (a) reverse engineer, decompile, distribute or disassemble the SDK,
 * 	    	except and only to the extent that applicable law expressly
 * 	    	permits; or
 * 		(b) make more copies of the SDK than specified in this agreement,
 * 			except and only to the extent applicable law expressly permits; or
 * 		(c) publish the SDK for others to copy; or
 * 		(d) rent, lease or lend the SDK.
 *
 * 	3. Use of the Service.
 * 	   Your use of the Services, and the use of the Services by anyone hosting
 * 	   or using your Authorized Application, is governed by the then-current
 * 	   Terms of Services which can be found at: https://stringflow.com/terms
 *
 * 	4. EXPORT RESTRICTIONS.
 * 		THE SDK IS SUBJECT TO UNITED STATES EXPORT LAWS AND REGULATIONS. YOU
 * 		MUST COMPLY WITH ALL DOMESTIC AND INTERNATIONAL EXPORT LAWS AND
 * 		REGULATIONS THAT APPLY TO THE SDK.
 *
 * 	5. Feedback.
 * 	   By submitting feedback to ALTERBASICS, either via email at
 * 	   support@stringflow.com or by any other means: You automatically grant
 * 	   to ALTERBASICS a perpetual, irrevocable, transferable, royalty-free
 * 	   license to use Your feedback for any and all purposes without any
 * 	   compensation to You.
 *
 * 	6. Termination.
 * 	   ALTERBASICS reserves the right to discontinue offering the SDK or
 * 	   Services or to modify the SDK or Services at any time in its sole
 * 	   discretion. This Section and Sections 3, 4, 5, 8, 9, 10, 11, and 12 will
 * 	   survive termination of this agreement or any discontinuation of the
 * 	   offering of the SDK or Services along with any other provisions that
 * 	   would reasonably be deemed to survive such events.
 *
 * 	7. Reservation of Rights.
 * 	   You are not authorized to alter, modify, copy, edit, format, create
 * 	   derivative works of or otherwise use any materials, content or
 * 	   technology provided under this agreement except as explicitly provided
 * 	   in this agreement or approved in advance in writing by ALTERBASICS.
 *
 * 	8. Modifications; Notices.
 * 	   If we change this contract, then we will give you notice before the
 * 	   change is in force. If you do not agree to these changes, then you must
 * 	   cancel and stop using the SDK and Services before the changes are in
 * 	   force. If you do not stop using the SDK or Services, then your use of
 * 	   the SDK or Services will continue under the changed contract.
 * 	   ALTERBASICS may give notices to You, at ALTERBASICS's option, by posting
 * 	   on any portion of ALTERBASICS.com or by electronic mail to any e-mail
 * 	   address provided by You to ALTERBASICS.
 *
 * 	9. Entire Agreement.
 * 	   This agreement, and any applicable TOS or contract for Services, are the
 * 	   entire agreement with respect to the SDK or Services.
 *
 * 	10. APPLICABLE LAW AND VENUE.
 * 	    Maharashtra state law governs the interpretation of this agreement and
 * 	    applies to claims for breach of it, regardless of conflict of laws
 * 	    principles.  The laws of the state where You live govern all other
 * 	    claims, including claims under state consumer protection laws, unfair
 * 	    competition laws, and in tort.
 * 	    You agree that any action brought under this agreement will be subject
 * 	    to exclusive jurisdiction and venue in the state and federal courts
 * 	    located in Pune (Maharashtra) India.
 *
 * 	11. Disclaimer of Warranty.
 * 		The SDK is licensed "as-is." You bear the risk of using it. ALTERBASICS
 * 		gives no express or implied warranties, guarantees or conditions. You
 * 		may have additional consumer rights under Your local laws which this
 * 		agreement cannot change. To the extent permitted under Your local laws,
 * 		ALTERBASICS excludes the implied warranties of merchantability, fitness
 * 		for a particular purpose and non-infringement. ALTERBASICS does not
 * 		represent or warrant that the SDK or the Services will always be
 * 		available, uninterrupted, secure, or error free.
 *
 * 	12. LIMITATION ON AND EXCLUSION OF REMEDIES AND DAMAGES.
 * 		You can recover from ALTERBASICS and its suppliers only direct damages
 * 		up to U.S. $5.00. You cannot recover any other damages, including
 * 		consequential, lost profits, special, indirect or incidental damages.
 * 		This limitation applies to:
 *
 * 		(a) anything related to the SDK, services, or content (including code)
 * 			on third party Internet sites, or third party programs; and
 * 		(b) claims for breach of contract, breach of warranty, guarantee or
 * 			condition, strict liability, negligence, or other tort to the
 * 			extent permitted by applicable law.
 *
 */
/**

 * # STRINGFLOW SDK LICENSE
 *
 * This is an agreement between You ("You") and ALTERBASICS Inc., located at
 * A1 306, Regency Orion, Baner,Pune, Maharashtra - 411045,India, ("ALTERBASICS")
 * regarding Your use of the Stringflow SDK and any associated documentation or
 * other materials made available by ALTERBASICS (collectively the "SDK").
 * This agreement applies to any updates or supplements for the SDK, unless other
 * terms accompany those items. If so, those other terms apply.
 *
 * By installing, accessing or otherwise using the SDK, You accept the terms of this
 * agreement. If You do not agree to the terms of this agreement, do not install,
 * access or use the SDK.
 *
 * If You comply with this agreement, You have the rights below.
 *
 * (1) USE OF THE SDK. Subject to Your compliance with this agreement, Stringflow
 * 	hereby authorizes You to use the SDK solely for the purpose of creating
 * 	mobile applications designed to operate with the Services (referred to as
 * 	"Authorized Applications"). You may not rent, lease or lend any of Your
 * 	rights in the SDK or access to the Services. You may make a reasonable
 * 	number of copies of the SDK for the purposes set forth herein, provided
 * 	that You reproduce only complete copies, including without limitation all
 * 	"read me" files, copyright notices, and other legal notices and terms that
 * 	ALTERBASICS has included in the SDK.
 *
 * (2) SCOPE OF LICENSE. The SDK is licensed, not sold. This agreement only gives
 * 	You some rights to use the SDK. ALTERBASICS specifically does not grant any
 * 	express or implied rights under its patents with respect to your Authorized
 * 	Applications. In doing so, You must comply with any technical limitations
 * 	in the SDK that only allow You to use it in certain ways. You may not:
 * 	    (a) reverse engineer, decompile, distribute or disassemble the SDK, except
 * 	    	and only to the extent that applicable law expressly permits; or
 * 		(b) make more copies of the SDK than specified in this agreement, except
 * 			and only to the extent applicable law expressly permits; or
 * 		(c) publish the SDK for others to copy; or
 * 		(d) rent, lease or lend the SDK.
 *
 * (3) USE OF THE SERVICES. Your use of the Services, and the use of the Services by
 * 	anyone hosting or using your Authorized Application, is governed by the
 * 	then-current Terms of Services (â€œTOSâ€�) which can be found
 * 	at: https://stringflow.com/terms
 *
 * (4) EXPORT RESTRICTIONS. THE SDK IS SUBJECT TO UNITED STATES EXPORT LAWS AND REGULATIONS.
 * 	YOU MUST COMPLY WITH ALL DOMESTIC AND INTERNATIONAL EXPORT LAWS AND REGULATIONS THAT
 * 	APPLY TO THE SDK.
 *
 * (5) FEEDBACK. By submitting feedback to ALTERBASICS, either via email at
 * 	support@stringflow.com or by any other means: You automatically grant to ALTERBASICS
 * 	a perpetual, irrevocable, transferable, royalty-free license to use Your feedback
 * 	for any and all purposes without any compensation to You.
 *
 * (6) TERMINATION. ALTERBASICS reserves the right to discontinue offering the SDK or Services
 * 	or to modify the SDK or Services at any time in its sole discretion. This Section and
 * 	Sections 3, 4, 5, 8, 9, 10, 11, and 12 will survive termination of this agreement or any
 * 	discontinuation of the offering of the SDK or Services along with any other provisions
 * 	that would reasonably be deemed to survive such events.
 *
 * (7) RESERVATION OF RIGHTS.  You are not authorized to alter, modify, copy, edit, format,
 * 	create derivative works of or otherwise use any materials, content or technology provided
 * 	under this agreement except as explicitly provided in this agreement or approved in
 * 	advance in writing by ALTERBASICS.
 *
 * (8) MODIFICATIONS; NOTICES. If we change this contract, then we will give you notice
 * 	before the change is in force. If you do not agree to these changes, then you must
 * 	cancel and stop using the SDK and Services before the changes are in force. If you
 * 	do not stop using the SDK or Services, then your use of the SDK or Services will
 * 	continue under the changed contract. ALTERBASICS may give notices to You, at
 * 	ALTERBASICS's option, by posting on any portion of ALTERBASICS.com or by electronic
 * 	mail to any e-mail address provided by You to ALTERBASICS.
 *
 * (9) ENTIRE AGREEMENT. This agreement, and any applicable TOS or contract for Services,
 * 	are the entire agreement with respect to the SDK or Services.
 *
 * (10) APPLICABLE LAW AND VENUE. California state law governs the interpretation of this
 * 	 agreement and applies to claims for breach of it, regardless of conflict of laws
 * 	 principles.  The laws of the state where You live govern all other claims, including
 * 	 claims under state consumer protection laws, unfair competition laws, and in tort.
 * 	 You agree that any action brought under this agreement will be subject to exclusive
 * 	 jurisdiction and venue in the state and federal courts located in Pune (Maharashtra)
 * 	 India.
 *
 * (11) DISCLAIMER OF WARRANTY. The SDK is licensed "as-is." You bear the risk of using it.
 * 	 ALTERBASICS gives no express or implied warranties, guarantees or conditions. You
 * 	 may have additional consumer rights under Your local laws which this agreement
 * 	 cannot change. To the extent permitted under Your local laws, ALTERBASICS excludes
 * 	 the implied warranties of merchantability, fitness for a particular purpose and
 * 	 non-infringement. ALTERBASICS does not represent or warrant that the SDK or the
 * 	 Services will always be available, uninterrupted, secure, or error free.
 *
 * (12) LIMITATION ON AND EXCLUSION OF REMEDIES AND DAMAGES. You can recover from ALTERBASICS
 * 	 and its suppliers only direct damages up to U.S. $5.00. You cannot recover any other
 * 	 damages, including consequential, lost profits, special, indirect or incidental damages.
 * 	 This limitation applies to:
 *
 * 	(a) anything related to the SDK, services, or content (including code) on third party
 * 		Internet sites, or third party programs; and
 * 	(b) claims for breach of contract, breach of warranty, guarantee or condition, strict
 * 		liability, negligence, or other tort to the extent permitted by applicable law.
 */
package abs.ixi.client;

import static java.util.Objects.nonNull;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import abs.ixi.client.core.Callback;
import abs.ixi.client.core.InitializationErrorException;
import abs.ixi.client.core.PacketCollector;
import abs.ixi.client.core.PacketForwarder;
import abs.ixi.client.core.ResponseCorrelator;
import abs.ixi.client.core.event.Event;
import abs.ixi.client.core.event.Event.EventType;
import abs.ixi.client.core.event.EventBus;
import abs.ixi.client.core.event.EventHandler;
import abs.ixi.client.core.event.EventListener;
import abs.ixi.client.io.StreamNegotiator.NegotiationResult;
import abs.ixi.client.io.UndeliveredStanzaManager;
import abs.ixi.client.io.XMPPStream;
import abs.ixi.client.io.XMPPStreamManager;
import abs.ixi.client.net.ConnectionManager;
import abs.ixi.client.net.NetworkException;
import abs.ixi.client.net.NetworkException.Reason;
import abs.ixi.client.util.LoggerUtil;
import abs.ixi.client.util.TaskExecutor;
import abs.ixi.client.xmpp.InvalidJabberId;
import abs.ixi.client.xmpp.JID;

/**
 * Custodian class which keeps all top level entity instances along with user
 * Session.
 * <p>
 * By design, {@code Platform} is singleton; there will be one platform instance
 * in memory at any given point
 * </p>
 */
public final class Platform {
	private static final Logger LOGGER = Logger.getLogger(Platform.class.getSimpleName());

	public static final String CHAT = "chat";
	public static final String DOT = ".";

	/**
	 * User Session instance; At a time Platform can hold only one user session
	 * which means SDK can never support two user sessions at the same time.
	 * Similarly there are only a sinlge instance of {@link XMPPStreamManager}
	 * which can manage a single xmpp stream only.
	 */
	private Session session;

	/**
	 * {@link XMPPStreamManager} instance; although stream manager belongs to IO
	 * Layer and shouldn't be available here. For now, it will be not possible
	 * to retrive it outside Platform using a <i>get</i> method
	 */
	private XMPPStreamManager streamManager;

	/**
	 * Singleton {@link UserManager} instance
	 */
	private UserManager userManager;

	/**
	 * Singleton {@link ChatManager} instance
	 */
	private ChatManager chatManager;

	/**
	 * Singleton {@link PresenceManager} instance
	 */
	private PresenceManager presenceManager;

	/**
	 * {@link ResponseCorrelator} instance
	 */
	private ResponseCorrelator responseCorrelator;

	/**
	 * Optional {@link UndeliveredStanzaManager}
	 */
	private UndeliveredStanzaManager undeliveredStanzaManager;

	/**
	 * Map of {@link PacketForwarder}s registered with Platform; Ideally all
	 * {@link PacketForwarder}s instantiated should be registered with Platform.
	 */
	private Map<String, PacketForwarder> forwarders;

	/**
	 * A flag to indicate if this Platform has been initialized
	 */
	private static volatile boolean initialized = false;

	/**
	 * A flag to indicate if user is successfully logged in or not on current
	 * {@link XMPPStream}.
	 */
	private volatile boolean loggedIn = false;

	/**
	 * Platform instance
	 */
	private static Platform instance;

	/**
	 * {@code Platform} is a Singleton therefore constructor has been kept
	 * private forcing developers to use {@link Platform#getInstance()}
	 */
	private Platform() {
		LoggerUtil.initializeLogger(Level.ALL);

		this.session = new Session();
		this.forwarders = new HashMap<>();
	}

	/**
	 * @return Platform instance; if the Platform has not been initialized using
	 *         {@link Platform#initialize(SDKInitializer)} before invoking this
	 *         method, the call will throw {@link NotInitializedException} which
	 *         is a {@link RuntimeException}
	 */
	public synchronized static Platform getInstance() {
		if (instance == null || !initialized) {
			throw new NotInitializedException("Platform must be initialized before it's use");
		}

		return instance;
	}

	/**
	 * Initialize SDK Platform. This is the entry point of SDK. If the Platform
	 * is not initialized before its use, any attempt to operate with Platform
	 * will throw {@link NotInitializedException}
	 * 
	 * @param initializer {@link SDKInitializer} instance which will be used by
	 *            the Platform to instantiate SDK objects
	 * @return true if platform was initilized successfully otherwise false
	 * @throws InitializationErrorException indicating platform initialization
	 *             failure
	 */
	public static synchronized boolean initialize(SDKInitializer initializer) throws InitializationErrorException {
		try {
			if (initialized) {
				LOGGER.log(Level.INFO, "Plateform is already initilized");

			} else {

				instance = new Platform();

				initializer.init();

				instance.streamManager = initializer.getStreamManager();
				instance.userManager = initializer.getUserManager();
				instance.chatManager = initializer.getChatManager();
				instance.presenceManager = initializer.getPresenceManager();
				instance.responseCorrelator = initializer.getResponseCorrelator();
				instance.undeliveredStanzaManager = initializer.getUndeliveredStanzaManager();

				initialized = true;
			}

			return initialized;

		} catch (Exception e) {
			LOGGER.log(Level.SEVERE, "Failed to initialize sdk", e);
			throw new InitializationErrorException(e);
		}
	}

	/**
	 * Clears user session data.
	 */
	public void clearUserSession() {
		this.session.reset();
	}

	/**
	 * Return logged in user's {@link JID}
	 * 
	 * @return User {@link JID}
	 */
	public JID getUserJID() {
		return (JID) this.session.get(Session.KEY_USER_JID);
	}

	/**
	 * Return logged in user's name
	 * 
	 * @return name of the user
	 */
	public String getUserName() {
		return (String) this.session.get(Session.KEY_USER_NAME);
	}

	/**
	 * Returns domain name
	 * 
	 * @return domain of the user
	 */
	public String getDomain() {
		return (String) this.session.get(Session.KEY_DOMAIN);
	}

	/**
	 * Returns domain name
	 * 
	 * @return {@link JID} of the server
	 * @throws InvalidJabberId if the JID format is not correct
	 */
	public JID getServerJID() throws InvalidJabberId {
		return new JID(this.getDomain());
	}

	/**
	 * Returns MUC service name
	 * 
	 * @return service name
	 */
	public String getMucServiceName() {
		return this.session.get(Session.KEY_MUC_SERVICE).toString();
	}

	/**
	 * Returns MUC service JID
	 * 
	 * @return MUC Service {@link JID}
	 * @throws InvalidJabberId if the JID instantiation fails
	 */
	public JID getMucServiceJID() throws InvalidJabberId {
		return new JID(this.session.get(Session.KEY_MUC_SERVICE).toString());
	}

	public JID getJabberSearchServiceJID() {
		throw new UnsupportedOperationException();
	}

	private String getMucService(String domain) {
		return new StringBuilder(CHAT).append(DOT).append(domain).toString();
	}

	public void addUndeliveredStanzaManager(UndeliveredStanzaManager undeliveredStanzaManager) {
		this.undeliveredStanzaManager = undeliveredStanzaManager;
		addEventHandler(Event.EventType.SERVER_ACK_RECEIVED, this.undeliveredStanzaManager);
	}

	public void removeUndeliveredStanzaManager() {
		removeEventHandler(Event.EventType.SERVER_ACK_RECEIVED, this.undeliveredStanzaManager);
		this.undeliveredStanzaManager = null;
	}

	public UndeliveredStanzaManager getUndeliveredStanzaManager() {
		return undeliveredStanzaManager;
	}

	public void setIsSMSupported(boolean isSupported) {
		this.session.put(Session.KEY_IS_SM_SUPPORTED, isSupported);
	}

	public boolean isSMSupported(boolean defaultValue) {
		return this.session.get(Session.KEY_IS_SM_SUPPORTED) == null ? defaultValue
				: (boolean) this.session.get(Session.KEY_IS_SM_SUPPORTED);
	}

	public void setMaxResumptionTimeInSec(int maxResumptionTimeInSec) {
		this.session.put(Session.KEY_MAX_RESUMPTION_TIME_IN_SEC, maxResumptionTimeInSec);
	}

	public int getMaxResumptionTimeInSec(int defaultValue) {
		return this.session.get(Session.KEY_MAX_RESUMPTION_TIME_IN_SEC) == null ? defaultValue
				: (int) this.session.get(Session.KEY_MAX_RESUMPTION_TIME_IN_SEC);
	}

	/**
	 * Convenience method to store some key values in user session.
	 * 
	 * @param key String key
	 * @param value value object
	 */
	public static void put(String key, Object value) {
		if (nonNull(instance))
			instance.getUserSession().put(key, value);

	}

	/**
	 * Convenience method to get stored value for some key.
	 * 
	 * @param key key for the value to be retrieved
	 * @return value object instance if found otherwise null
	 */
	public static Object get(String key) {
		if (nonNull(instance))
			return instance.getUserSession().get(key);

		return null;
	}

	/**
	 * Raise event which is fired on the event bus held by the user session
	 * 
	 * @param type type of the event to be raised
	 * @param source source object instance
	 */
	public static void raiseEvent(EventType type, Object source) {
		if (nonNull(instance))
			instance.getUserSession().getEventBus().fire(new Event(type, source));
	}

	/**
	 * Convenience method to add {@link EventListener} to {@link EventBus} in
	 * session
	 * 
	 * @param eventClz event class for which event listener will be invoked
	 * @param listener event listener instance
	 * @param <E> generic
	 */
	public static <E extends Event> void addEventListener(Class<E> eventClz, EventListener<E> listener) {
		instance.getUserSession().getEventBus().addListener(eventClz, listener);
	}

	/**
	 * Convenience method to add {@link EventHandler} to {@link EventBus} in
	 * session
	 * 
	 * @param type {@link EventType}
	 * @param handler {@link EventHandler} instance
	 */
	public static void addEventHandler(EventType type, EventHandler handler) {
		instance.getUserSession().getEventBus().addHandler(type, handler);
	}

	/**
	 * Convenience method to remove {@link EventHandler} to {@link EventBus} in
	 * session
	 * 
	 * @param type {@link EventType}
	 * @param handler {@link EventHandler} instance
	 */
	public static void removeEventHandler(EventType type, EventHandler handler) {
		instance.getUserSession().getEventBus().remove(type, handler);
	}

	/**
	 * Register a {@link PacketCollector} with a {@link PacketForwarder} to tap
	 * into the packet stream
	 * 
	 * @param collector {@link PacketCollector} to be registered
	 * @param fName {@link PacketForwarder} name
	 * @return true if {@link PacketForwarder} was found registered with
	 *         Platform and given collector was registered with the forwarder
	 *         otherwise false
	 */
	public boolean registerPacketCollector(PacketCollector collector, String fName) {
		// TODO Implement it
		throw new UnsupportedOperationException("This op is not supported yet");
	}

	// Above this point Refactoring is required

	/**
	 * Start XMPP stream with given user credentials. Stream negotiations are
	 * done synchronously; therefore method call will return only when
	 * negotiation process is complete.
	 * 
	 * @param userName userName of the user trying to login
	 * @param passwd user password
	 * @param domain user domain in which user will login
	 * @return {@link NegotiationResult} instance with stream negotiation
	 *         outcome
	 * @throws NetworkException if IO error occurs while reading/writing on
	 *             connection
	 */
	public synchronized NegotiationResult login(final String userName, final String domain, final String passwd)
			throws NetworkException {

		NegotiationResult result = this.streamManager.startStream(userName, passwd, domain);

		if (result.isSuccess()) {
			storeUserAuthInfo(userName, domain, passwd);
		}

		return result;
	}

	/**
	 * Start XMPP stream with given user credentials. Once stream negotiation is
	 * complete, {@link Callback} will be invoked with {@link NegotiationResult}
	 * object which application can process to find out the exact outcome of the
	 * negotiation process.
	 * <p>
	 * During negotiations, if IO error occurs while writing/reading on/from
	 * socket, {@link Callback} will be invoked with {@link NetworkException}.
	 * Additionally, if the underlying device does not have network
	 * connectivity, {@link Callback} will be invoked with
	 * {@link NetworkException} with {@link Reason#NO_CONNECTIVITY}
	 * </p>
	 * 
	 * @param userName userName of the user trying to login
	 * @param domain user domain in which user will login
	 * @param passwd user password
	 * @param callback callback implementation to be invoked
	 */
	public void login(final String userName, final String domain, final String passwd,
			final Callback<NegotiationResult, Exception> callback) {

		TaskExecutor.submit(new Runnable() {
			@Override
			public void run() {
				try {
					NegotiationResult result = streamManager.startStream(userName, passwd, domain);
					storeUserAuthInfo(userName, domain, passwd);
					callback.onSuccess(result);

				} catch (Exception e) {
					callback.onFailure(e);
				}
			}
		});
	}

	/**
	 * Store user auth information inside session. Typically when stream has
	 * been authenticated, user auth info is stored inside session.
	 * 
	 * @param userName userName
	 * @param domain domain of the userName
	 * @param passwd password (plain text)
	 */
	private void storeUserAuthInfo(final String userName, final String domain, final String passwd) {
		this.session.put(Session.KEY_USER_NAME, userName);
		this.session.put(Session.KEY_USER_PASSWORD, passwd);
		this.session.put(Session.KEY_DOMAIN, domain);
		this.session.put(Session.KEY_MUC_SERVICE, getMucService(domain));
		this.session.put(Session.KEY_USER_JID, new JID(userName, domain));
		this.session.setAuthenticated(true);
	}

	/**
	 * Return user is authenticated or not on current stream.
	 * 
	 * @return true if current user has already been authenticated otherwise
	 *         false
	 */
	public boolean isUserAuthenticated() {
		return this.session.isAuthenticated();
	}

	/**
	 * @return {@link Session} instance
	 */
	public Session getUserSession() {
		return this.session;
	}

	/**
	 * @return {@link ChatManager} instance
	 */
	public ChatManager getChatManager() {
		return this.chatManager;
	}

	/**
	 * @return {@link PresenceManager} instance
	 */
	public PresenceManager getPresenceManager() {
		return this.presenceManager;
	}

	/**
	 * @return {@link UserManager} instance
	 */
	public UserManager getUserManager() {
		return this.userManager;
	}

	/**
	 * @return {@link ResponseCorrelator} instance
	 */
	public ResponseCorrelator getResponseCorrelator() {
		return this.responseCorrelator;
	}

	/**
	 * User logout is protocol level action which simply closes the ongoing
	 * stream with server.
	 * 
	 * @throws NetworkException when there is any network related error
	 */
	public void logout() throws NetworkException {
		this.streamManager.closeStream();
		this.session = null;
	}

	/**
	 * Shutdown this platform instance; this action is irreversible. As part of
	 * platform shutdown, all the manager entities ({@linkplain UserManager},
	 * {@link ChatManager} and {@link PresenceManager}) along with XMPP Stream
	 * are shutdown and connections are closed.
	 * <p>
	 * Once the Platform is shutdown, it's state can not be reconstructed;
	 * therefore it's the final call to the Platform. Typically when application
	 * is getting removed from memeory, Platform will be shutdown. For actions
	 * such as user logout, the platform should also be logged out instead of
	 * shutdown.
	 * </p>
	 */
	public void shutdown() {
		this.streamManager.shutdown();

		ConnectionManager.getInstance().shutdown();

		this.chatManager = null;
		this.presenceManager = null;
		this.userManager = null;
		this.responseCorrelator = null;
		this.undeliveredStanzaManager = null;
		this.streamManager = null;

		if (this.session != null) {
			this.session.invalidate();
		}

		// Remove platform only when everything else is shutdown because
		// Platform may be accessed during shutdown (Platform.getInstance())
		instance = null;
		initialized = false;
	}

}
